// Minimal password prompt (Arduino) â€” password not stored in clear in .elf
#include <Arduino.h>
#include <SoftwareSerial.h>
#include <Crypto.h>
#include <SHA3.h>
#include <avr/pgmspace.h>


const uint8_t OBFUSCATION_KEY = 0xAA;

// Obfuscated (digest ^ OBFUSCATION_KEY) stored in PROGMEM so it's not trivially visible as ascii.
// This value corresponds to SHA3-256("f7-@Jp0w") XOR 0xAA.
// (If you change password, recompute and re-obfuscate accordingly.)
const uint8_t OBFUSCATED_DIGEST_PROGMEM[32] PROGMEM = {
  0xFB,0x38,0x79,0x22,0x2E,0x95,0x68,0x43,
  0xF8,0x32,0x62,0xCC,0xD1,0xAE,0x37,0x70,
  0x66,0x10,0x4A,0xFA,0x89,0x32,0xCB,0x49,
  0x25,0x5F,0x94,0xE6,0xB0,0x8F,0xB1,0x92
};

// other program data (unchanged)
const char *secret = "Je suis une petite tortue";
const int salt_size = 4;
uint8_t digest[32]; // buffer used for computing the secret hash to show in protected_section

// choose pins: RX is the pin Arduino listens on (connect TX of other device here)
// TX is the pin Arduino transmits on (connect RX of other device here)
const uint8_t MY_RX_PIN = 10;
const uint8_t MY_TX_PIN = 11;

SoftwareSerial comms(MY_RX_PIN, MY_TX_PIN); // RX, TX

void setup() {
  Serial.begin(115200);
  while (!Serial) { delay(10); }
  Serial.println();
  Serial.println("Welcome to the vault. This is not the main entrance.");
  comms.begin(9600);          // software serial communications
  comms.println("Enter password:");

  pinMode(13, OUTPUT);
  digitalWrite(13, LOW);
}

// Reconstruct expected digest from obfuscated bytes stored in PROGMEM
void reconstruct_expected_digest(uint8_t *outDigest) {
  for (size_t i = 0; i < 32; ++i) {
    uint8_t b = pgm_read_byte_near(OBFUSCATED_DIGEST_PROGMEM + i);
    outDigest[i] = b ^ OBFUSCATION_KEY;
  }
}

// Hash password with optional salt (same as your original hash function)
void hashPassword(const char *password, const uint8_t *salt, size_t saltLen, uint8_t *outDigest) {
  SHA3_256 sha3;
  sha3.reset();

  // Add salt
  if (salt != nullptr && saltLen > 0) {
    sha3.update(salt, saltLen);
  }

  // Add password
  sha3.update((const uint8_t *)password, strlen(password));

  // Finalize
  sha3.finalize(outDigest, 32);
}

String readLine(Stream &s) {
  String str;
  while (true) {
    if (s.available()) {
      char c = s.read();
      if (c == '\r' or c == '\n') break;
      str += c;
    }
  }
  return str;
}

// constant-time comparison of two buffers (length bytes)
bool constant_time_compare(const uint8_t *a, const uint8_t *b, size_t length) {
  uint8_t diff = 0;
  for (size_t i = 0; i < length; ++i) {
    diff |= a[i] ^ b[i];
  }
  return diff == 0;
}

void protected_section(Stream &out) {
  out.println(">> ACCESS GRANTED: running protected section");

  uint8_t SALT[4];
  for (int i = 0; i < salt_size; i++) {
    SALT[i] = (uint8_t) random(0x21, 0x7E);
  }

  hashPassword(secret, SALT, sizeof(SALT), digest);

  out.print("Here is your salt: ");
  for (int i = 0; i < 4; i++) {
    if (SALT[i] < 0x10) out.print("0");
    out.print(SALT[i], HEX);
  }
  out.println();
  out.print("Here is your hash: ");
  for (int i = 0; i < 32; i++) {
    if (digest[i] < 0x10) out.print("0");
    out.print(digest[i], HEX);
  }
  out.println();
}

void loop() {
  if (comms.available()) {
    String attempt = readLine(comms);
    attempt.trim();
    if (attempt.length() == 0) {
      comms.println("No input. Enter password:");
      return;
    }

    // compute SHA3-256 of attempt (no salt, because expected digest was computed without salt)
    uint8_t attempt_digest[32];
    hashPassword(attempt.c_str(), nullptr, 0, attempt_digest);

    // reconstruct expected digest
    uint8_t expected_digest[32];
    reconstruct_expected_digest(expected_digest);

    digitalWrite(13, HIGH);

    if (constant_time_compare(attempt_digest, expected_digest, 32)) {
      protected_section(comms);
    } else {
      comms.println(">> ACCESS DENIED");
    }
    digitalWrite(13, LOW);

    comms.println();
    comms.println("Enter password:");
  }
}
